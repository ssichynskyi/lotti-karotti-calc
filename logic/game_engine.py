# -*- coding: utf-8 -*-
from abc import ABC, abstractmethod
from logic.player import Player, NewPlayerGenerator
from logic.stack import Stack
from logic.playfield import PlayField, PlayFieldCell


class GameEngine(ABC):
    """
    Abstract base class for game engines
    """
    @abstractmethod
    def reset_game(self):
        raise NotImplementedError

    @abstractmethod
    def run_game(self):
        raise NotImplementedError


class LottiGameEngine(GameEngine):
    """
    This class represent the entire game engine with it's physics and rules
    """
    def __init__(self, number_of_players: int, config):
        """
        initializes the new game and it's components from config:
        - players
        - play field
        :param number_of_players: number of players in the game
        :param config: config object as generated by config module
        """

        self._play_field = PlayField(
            config.options['playfield']['number_of_cells'],
            config.options['playfield']['holes']
        )

        self._players = list(NewPlayerGenerator(
            config.options['rabbits_per_player'],
            number_of_players
        ))

        self._rabbit_map = dict()
        self._reset_positions()

        self._stack = Stack(config.options['stack'])

    def _reset_positions(self):
        self._rabbit_map = {
            rabbit: self._play_field.starting_cell
            for player in self._players
            for rabbit in player.ready_rabbits
        }

    @property
    def play_field(self) -> PlayField:
        """
        :return: play field
        """
        return self._play_field

    @property
    def players(self) -> [Player]:
        """
        :return: list of players
        """
        return self._players

    def is_busy(self, cell: PlayFieldCell) -> bool:
        """
        checks if cell, given is parameter is busy by other chip (rabbit)
        :param cell: cell to check
        :return: True if a given cell is busy, False in other case
        """
        for busy_cell in self._rabbit_map.values():
            if cell == busy_cell:
                return True
        return False

    def reset_game(self) -> None:
        """
        Perform reset all game settings to it's defaults.
        Normally done to start a new game
        :return: None
        """
        self._play_field.reset_condition()
        for player in self._players:
            player.reset_condition()
        self._reset_positions()

    def examine_positions(self) -> None:
        """
        Check if any chip (rabbit) is not standing on a hole.
        If so, calls the method to drop the rabbit
        :return: None
        """
        for player in self._players:
            if player.is_active:
                rabbit = player.get_active_rabbit()
                if self._rabbit_map[rabbit].is_hole:
                    player.drop_active_rabbit()
                    self._rabbit_map[rabbit] = None

    def move_players_chip(self, player: Player, steps: int) -> Player or None:
        """
        Moves player chip by given amount of steps
        :param player: who is making this turn
        :param steps: number of steps to do
        :return: Player, if he wins the game during this action,
        None in other case
        """
        rabbit = player.get_active_rabbit()
        # handle rare case when player had dropped last own rabbit on this turn
        if rabbit is None:
            return None
        destination_cell = self._rabbit_map[rabbit]
        while (steps > 0) and (not destination_cell.is_winning_cell):
            destination_cell = destination_cell.next
            if not self.is_busy(destination_cell):
                steps -= 1
        if destination_cell != self._rabbit_map[rabbit]:
            self._rabbit_map[rabbit] = destination_cell
            print(f'Rabbit #{player.id}.{rabbit.number} moves to cell #{destination_cell.number}')
        if destination_cell.is_winning_cell:
            return player
        if destination_cell.is_hole:
            player.drop_active_rabbit()
            self._rabbit_map[rabbit] = None

    def make_turn(self, player: Player) -> Player or None:
        """
        Executes the turn according to the rules of the game
        :param player: player object that makes the turn
        :return: Player if it wins during this turn, None in other case
        """
        card = self._stack.pull_card()
        return self.perform_player_action(player, card)

    def perform_player_action(self, player: Player, card) -> Player or None:
        print(f'Player {player.id} picks a card R{card.rotate}, M{card.move}')
        # apply rotation effects
        self._play_field.rotate_carrot(card.rotate)
        self.examine_positions()
        # apply moving
        return self.move_players_chip(player, card.move)

    def run_game(self) -> Player.id or None:
        """
        Run game and return winner player. In case of draw return None
        :return: Player or None
        """
        self.reset_game()
        draw = False
        winner = None
        turn = 0
        while not draw and not winner:
            turn += 1
            print(f'---------------TURN #{turn} ---------------')
            draw = True
            for player in self._players:
                if player.is_active:
                    draw = False
                    winner = self.make_turn(player)
                    if winner:
                        return winner.id
                else:
                    print(f'Player #{player.id} is out of the game')
        return None
